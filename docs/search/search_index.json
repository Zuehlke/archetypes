{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>A developer's career rarely follows a single, linear path. As skills and interests evolve, so too do job titles and aspirations. How can we support this variety of career goals while still aligning with the needs of the business?</p> <p>One approach is to introduce Career Pathways and Archetypes.</p>"},{"location":"#career-pathways","title":"Career Pathways","text":"<p>Practice leads and senior practitioners collaboratively define Career Pathways. They include core capabilities - common to all developers - and optional specialisms that reflect individual focus areas. Developer Archetypes help describe these specialisms. Examples include: Backend Developer, Frontend Developer, Mobile Developer, DevOps Engineer, Tech Lead, Infrastructure Developer, Data Engineer, Platform Engineer, API Developer, Data Platform Specialist, Application Architect, Systems Architect, Security Architect, AppSec Developer, Account Technical Principal, and Executive Technical Principal  -  to name just a few.</p> <p>These archetypes are built on a shared foundation of capabilities and follow a simple Dreyfus-based maturity model, independent of promotion conversations. One person may span multiple archetypes, reflecting the diversity of modern software roles.</p> <p>We'll define an approval structure for Archetypes as we refine this model. However, the key idea remains: a flexible, transparent framework that supports individual growth and evolving business needs.</p>"},{"location":"#archetypes","title":"Archetypes","text":"<p>\"Archetypes\" are a shorthand for describing key competencies that support delivering our services.</p> <p>They go beyond job titles - offering more depth than a role description, while remaining concise and practical. Rather than listing every possible skill, archetypes focus on the most critical capabilities for that particular path.</p> <p>Each archetype includes expected outcomes - a way to clarify what success typically looks like in that role. They are archetypal examples: not an exhaustive model of every edge case, but a clear picture of the skills needed to deliver the expected results.</p> <p>People can shape their careers by combining core and optional components aligned with one or more archetypes. This approach helps avoid name-centric staffing, supports fairer recruitment, and empowers individuals to take ownership of their growth.</p> <p>Importantly, a person is not an archetype - they may align with several at once. Archetypes can also help design well-rounded teams for pitches, bids, and project planning, ensuring the right mix of skills is in place.</p>"},{"location":"#who-are-we","title":"Who are we?","text":"<p>This initiative is driven by the Z\u00fchlke Software Excellence practice.</p>"},{"location":"#the-software-engineering-corner","title":"The Software Engineering Corner","text":"<p>The Software Engineering Corner is a technical blog curated by engineers at Z\u00fchlke. The blog features articles on topics such as refactoring legacy systems, implementing micro frontends, enhancing application observability, and adopting green coding practices. Each post reflects real-world experiences and lessons learned from client engagements, providing valuable knowledge for software professionals.</p>"},{"location":"#license","title":"License","text":"<p>This work is licensed under CC BY-NC-SA 4.0. </p> <p></p>"},{"location":"archetypes/core-software-engineer-archetype/","title":"Core Software Engineer Archetype","text":"<p>The Core Software Engineer represents the foundation of technical excellence at Z\u00fchlke. This archetype embodies the essential engineering competencies that underpin all software development roles, regardless of specialism.  Core Software Engineers are skilled in writing clean, maintainable code, applying sound engineering principles, and working effectively within delivery teams.</p> <p>They focus on solving real problems through technology, continuously improving their craft, and contributing to a culture of quality and collaboration. The Core Software Engineer is not just about technical skill - it's about mindset, discipline, and a commitment to delivering value.</p> <p>This archetype forms the basis for many others and is often the first step in shaping a career path at Z\u00fchlke.</p>"},{"location":"archetypes/core-software-engineer-archetype/#novice","title":"Novice","text":"<ul> <li>Developer Tooling\u00a0basics</li> <li>Primary Programming Language</li> <li>Collaboration Tools</li> <li>HTML/CSS basics</li> <li>Basics of software development lifecycle</li> <li>Agile basics</li> <li>Version Control Systems</li> </ul>"},{"location":"archetypes/core-software-engineer-archetype/#advanced-beginner","title":"Advanced Beginner","text":"<ul> <li>The Test Pyramind</li> <li>Test Driven Development (TDD)</li> <li>Extreme Programming Practices</li> <li>Technical Documentation Writing</li> <li>SCRUM</li> <li>Continuous Integration</li> <li>User Stories</li> <li>Relational Databases</li> <li>NoSQL Databases</li> <li>Debugging</li> <li>OS Shell basics</li> <li>Prompt Engineering Skills for Engineers</li> <li>Data Structures</li> <li>Security Basics</li> <li>OWASP Top 10</li> <li>Software Design Modelling &amp; Diagramming Languages (e.g. UML, C4, ERM)</li> <li>Gang of Four Design Patterns</li> <li>DevOps Mindset</li> <li>Internet Protocols (e.g. DNS, TCP/IP, HTTP, TLS, etc)</li> <li>Monitoring and Observability</li> <li>Containers and Orchestration</li> </ul>"},{"location":"archetypes/core-software-engineer-archetype/#competent","title":"Competent","text":"<ul> <li>SOLID</li> <li>Clean Code and Refactoring</li> <li>Integrated Component Tests</li> <li>Technical Architecture Intro</li> <li>Data Modeling adnd Databases</li> <li>Continuous Delivery</li> <li>Legacy Systems</li> <li>Root Cause Analysis</li> <li>Cloud Computing</li> <li>MultipleLanguages and Paradigms</li> <li>Automated end-to-end System Testing</li> <li>Styleguides and Linting</li> <li>REST design</li> <li>General API Design and Security Principles</li> <li>Domain Driven Design</li> <li>Cloud Native 12 Factor App Principles</li> <li>Performance and Scalability</li> <li>Component Architectures</li> <li>Shifting Left Security</li> <li>Communication and Presentation Skills</li> <li>User Story Mapping</li> <li>Non Functional Requirements</li> </ul>"},{"location":"archetypes/core-software-engineer-archetype/#proficient","title":"Proficient","text":"<ul> <li>Advanced Programming</li> <li>Building Evolutionary Architectures</li> <li>Threat Modelling</li> <li>Profiling &amp; performance tuning</li> <li>Enterprise Design Patterns</li> <li>Building for Scale</li> <li>API as a Product</li> <li>Distributed Systems Theory &amp; Practices</li> <li>Facilitating Agile</li> <li>Mentoring and Coaching</li> <li>Agile @ Scale</li> <li>Effective Collaboration</li> <li>Chaos Engineering</li> </ul>"},{"location":"archetypes/core-software-engineer-archetype/#expert","title":"Expert","text":"<ul> <li>Systems and Complexity Sciences</li> <li>Site Reliability Engineering for Developers</li> <li>Ethical and Responsible Tech</li> <li>GDPR and other governance requirements</li> <li>Knowledge of intellectual property laws, data privacy and ethical hacking practices</li> <li>Economics &amp; FinOps</li> <li>Emerging Technologies &amp; Tech Trends</li> </ul>"},{"location":"topics/extreme-programming-practices/","title":"Extreme Programming (XP) Practices","text":"<p>Extreme Programming (XP) is an agile software development methodology emphasising technical excellence and customer satisfaction through reinforcing practices. Built on simplicity, communication, feedback, courage, and respect, XP takes effective engineering practices to \"extreme\" levels\u2014continuous integration happens often daily, pair programming replaces individual development, and customer representatives work directly with the team. XP embraces change by using short development cycles, incremental planning, and automated testing to deliver high-quality software that evolves with changing requirements. Rather than viewing change as a threat to project timelines, XP treats it as an inevitable reality and builds processes that harness change to create better products that meet customer needs.</p>"},{"location":"topics/extreme-programming-practices/#practices","title":"Practices","text":"<ul> <li>Pair Programming</li> <li>Test-Driven Development</li> <li>Continuous Integration</li> <li>Refactoring</li> <li>Simple Design</li> <li>Collective Code Ownership</li> <li>Coding Standards</li> <li>Sustainable Pace</li> <li>Whole Team</li> <li>Small Releases</li> <li>On-Site Customer</li> </ul>"},{"location":"topics/integrated-component-tests/","title":"Integrated Component Tests","text":""},{"location":"topics/integrated-component-tests/#learning-resources","title":"Learning Resources","text":"<ul> <li>Testing Strategies in a Microservice Architecture</li> </ul>"},{"location":"topics/legacy-systems/","title":"Legacy Systems","text":""},{"location":"topics/legacy-systems/#articles","title":"Articles","text":"<ul> <li>Refactoring Legacy Code using Tiny Types and Data Oriented Programming in Java</li> <li>Untangling Legacy Systems</li> </ul>"},{"location":"topics/legacy-systems/#learning-resources","title":"Learning Resources","text":"<ul> <li>Writing Good Tests with JUnit </li> </ul>"},{"location":"topics/pair-programming/","title":"Pair Programming","text":"<p>Pair programming is a collaborative software development technique in which two programmers work together at a single workstation to solve the same problem simultaneously. This approach results in higher code quality, fewer defects, improved team cohesion, and faster skill development. Although it may seem counterintuitive to managers concerned about productivity, research indicates that the slight increase in development time is often outweighed by significant reductions in debugging and maintenance costs later on.</p>"},{"location":"topics/pair-programming/#presentation","title":"Presentation","text":""},{"location":"topics/test-driven-development/","title":"Test Driven Development (TDD)","text":"<p>Test-driven development (TDD) is a software development approach that inverts the traditional coding process by writing tests before implementing functionality. Rather than writing code first and testing later, developers begin by creating automated tests that define the desired behaviour, then write the minimal code needed to pass those tests, and finally refactor to improve quality while ensuring tests still pass. This methodical cycle\u2014test, code, refactor leads to more reliable software with fewer bugs, a cleaner architecture, and better documentation of intended behaviour. TDD serves as a verification mechanism and a design tool, encouraging developers to think critically about requirements and implementation details before writing a single line of production code.</p>"},{"location":"topics/test-driven-development/#talks","title":"Talks","text":""},{"location":"topics/test-driven-development/#learning-resources","title":"Learning Resources","text":"<ul> <li>Beck, K. (2023). Tidy First?</li> <li>Freeman, S. and Pryce, N. (2009). Growing Object-Oriented Software, Guided by Tests</li> <li>Writing Good Tests with JUnit </li> </ul>"},{"location":"topics/the-test-pyramid/","title":"The Test Pyramid","text":"<p>A well-balanced automated testing strategy is often visualised as a pyramid. At the base are unit tests\u2014small, fast, and reliable tests that verify individual components in isolation. These should form the majority of your test suite, as they offer quick feedback and are easy to maintain.</p> <p>In the middle are integration tests, which check that different parts of the system work correctly together. They're fewer in number and focus on critical interactions.</p> <p>At the top are end-to-end tests, which simulate real user journeys through the system. These are the slowest and most fragile, so they should be used sparingly and only for key workflows.</p> <p>This layered approach helps teams catch bugs early, run tests quickly, and maintain a healthy, sustainable codebase. The goal isn't just more tests, but the right tests at the right levels.</p>"},{"location":"topics/the-test-pyramid/#learning-resources","title":"Learning Resources","text":"<ul> <li>Fowler, M. (2014). The Practical Test Pyramid</li> <li>Writing Good Tests with JUnit </li> </ul>"},{"location":"topics/version-control-systems/","title":"Version Control Systems","text":"<p>Version control is a system that records changes to files over time, allowing developers to track modifications, compare versions, and revert to previous states when needed. At its core, version control serves as a project's timeline and safety net, enabling collaboration among team members while maintaining a complete history of what changed, when, and by whom. </p>"},{"location":"topics/version-control-systems/#learning-resources","title":"Learning Resources","text":"<ul> <li>https://learngitbranching.js.org/</li> </ul>"}]}