{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>A developer's career rarely follows a single, linear path. As skills and interests evolve, so too do job titles and aspirations. How can we support this variety of career goals while still aligning with the needs of the business?</p> <p>One approach is to introduce Career Pathways and Archetypes.</p>"},{"location":"#career-pathways","title":"Career Pathways","text":"<p>Practice leads and senior practitioners collaboratively define Career Pathways. They include core capabilities - common to all developers - and optional specialisms that reflect individual focus areas. Developer Archetypes help describe these specialisms. Examples include: Backend Developer, Frontend Developer, Mobile Developer, DevOps Engineer, Tech Lead, Infrastructure Developer, Data Engineer, Platform Engineer, API Developer, Data Platform Specialist, Application Architect, Systems Architect, Security Architect, AppSec Developer, Account Technical Principal, and Executive Technical Principal  -  to name just a few.</p> <p>These archetypes are built on a shared foundation of capabilities and follow a simple Dreyfus-based maturity model, independent of promotion conversations. One person may span multiple archetypes, reflecting the diversity of modern software roles.</p> <p>We'll define an approval structure for Archetypes as we refine this model. However, the key idea remains: a flexible, transparent framework that supports individual growth and evolving business needs.</p>"},{"location":"#archetypes","title":"Archetypes","text":"<p>\"Archetypes\" are a shorthand for describing key competencies that support delivering our services.</p> <p>They go beyond job titles - offering more depth than a role description, while remaining concise and practical. Rather than listing every possible skill, archetypes focus on the most critical capabilities for that particular path.</p> <p>Each archetype includes expected outcomes - a way to clarify what success typically looks like in that role. They are archetypal examples: not an exhaustive model of every edge case, but a clear picture of the skills needed to deliver the expected results.</p> <p>People can shape their careers by combining core and optional components aligned with one or more archetypes. This approach helps avoid name-centric staffing, supports fairer recruitment, and empowers individuals to take ownership of their growth.</p> <p>Importantly, a person is not an archetype - they may align with several at once. Archetypes can also help design well-rounded teams for pitches, bids, and project planning, ensuring the right mix of skills is in place.</p>"},{"location":"#who-are-we","title":"Who are we?","text":"<p>This initiative is driven by the Z\u00fchlke Software Excellence practice.</p>"},{"location":"#license","title":"License","text":"<p>This work is licensed under CC BY-NC-SA 4.0. </p> <p></p>"},{"location":"archetypes/core-engineer-archetype/","title":"Core Engineer Archetype","text":"<p>The Core Engineer represents the foundation of technical excellence at Z\u00fchlke. This archetype embodies the essential engineering competencies that underpin all software development roles, regardless of specialism.  Core Engineers are skilled in writing clean, maintainable code, applying sound engineering principles, and working effectively within delivery teams.</p> <p>They focus on solving real problems through technology, continuously improving their craft, and contributing to a culture of quality and collaboration. The Core Engineer is not just about technical skill - it's about mindset, discipline, and a commitment to delivering value.</p> <p>This archetype forms the basis for many others and is often the first step in shaping a career path at Z\u00fchlke.</p>"},{"location":"archetypes/core-engineer-archetype/#novice","title":"Novice","text":"<ul> <li>Developer Tooling\u00a0basics</li> <li>Primary Programming Language</li> <li>Collaboration Tools</li> <li>HTML/CSS basics</li> <li>Basics of software development lifecycle</li> <li>Agile basics</li> <li>Version Control Systems</li> </ul>"},{"location":"archetypes/core-engineer-archetype/#advanced-beginner","title":"Advanced Beginner","text":"<ul> <li>The Test Pyramind</li> <li>Test Driven Development (TDD)</li> <li>Technical Documentation Writing</li> <li>SCRUM</li> <li>Continuous Integration</li> <li>User Stories</li> <li>Relational Databases</li> <li>NoSQL Databases</li> <li>Debugging</li> <li>OS Shell basics</li> <li>Prompt Engineering Skills for Engineers</li> <li>Data Structures</li> <li>Security Basics</li> <li>OWASP Top 10</li> <li>Software Design Modelling &amp; Diagramming Languages (e.g. UML, C4, ERM)</li> <li>Gang of Four Design Patterns</li> <li>XP Programming Practices</li> <li>DevOps Mindset</li> <li>Internet Protocols (e.g. DNS, TCP/IP, HTTP, TLS, etc)</li> <li>Monitoring and Observability</li> <li>Containers and Orchestration</li> </ul>"},{"location":"archetypes/core-engineer-archetype/#competent","title":"Competent","text":"<ul> <li>SOLID</li> <li>Clean Code and Refactoring</li> <li>Integrated Component Tests</li> <li>Technical Architecture Intro</li> <li>Data Modeling adnd Databases</li> <li>Continuous Delivery</li> <li>Legacy Codebase</li> <li>Root Cause Analysis</li> <li>Cloud Computing</li> <li>MultipleLanguages and Paradigms</li> <li>Automated end-to-end System Testing</li> <li>Styleguides and Linting</li> <li>REST design</li> <li>General API Design and Security Principles</li> <li>Domain Driven Design</li> <li>Cloud Native 12 Factor App Principles</li> <li>Performance and Scalability</li> <li>Component Architectures</li> <li>Shifting Left Security</li> <li>Communication and Presentation Skills</li> <li>User Story Mapping</li> <li>Non Functional Requirements</li> </ul>"},{"location":"archetypes/core-engineer-archetype/#proficient","title":"Proficient","text":"<ul> <li>Advanced Programming</li> <li>Building Evolutionary Architectures</li> <li>Threat Modelling</li> <li>Profiling &amp; performance tuning</li> <li>Enterprise Design Patterns</li> <li>Building for Scale</li> <li>API as a Product</li> <li>Distributed Systems Theory &amp; Practices</li> <li>Facilitating Agile</li> <li>Mentoring and Coaching</li> <li>Agile @ Scale</li> <li>Effective Collaboration</li> <li>Chaos Engineering</li> </ul>"},{"location":"archetypes/core-engineer-archetype/#expert","title":"Expert","text":"<ul> <li>Systems and Complexity Sciences</li> <li>Site Reliability Engineering for Developers</li> <li>Ethical and Responsible Tech</li> <li>GDPR and other governance requirements</li> <li>Knowledge of intellectual property laws, data privacy and ethical hacking practices</li> <li>Economics &amp; FinOps</li> <li>Emerging Technologies &amp; Tech Trends</li> </ul>"},{"location":"topics/the-test-pyramid/","title":"The Test Pyramid","text":"<p>A well-balanced automated testing strategy is often visualised as a pyramid. At the base are unit tests\u2014small, fast, and reliable tests that verify individual components in isolation. These should form the majority of your test suite, as they offer quick feedback and are easy to maintain.</p> <p>In the middle are integration tests, which check that different parts of the system work correctly together. They're fewer in number and focus on critical interactions.</p> <p>At the top are end-to-end tests, which simulate real user journeys through the system. These are the slowest and most fragile, so they should be used sparingly and only for key workflows.</p> <p>This layered approach helps teams catch bugs early, run tests quickly, and maintain a healthy, sustainable codebase. The goal isn't just more tests, but the right tests at the right levels.</p>"},{"location":"topics/the-test-pyramid/#learning-resources","title":"Learning Resources","text":"<ul> <li>Fowler, M. (2014). The Practical Test Pyramid</li> </ul>"}]}